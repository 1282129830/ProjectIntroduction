#### 什么是线程池

线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用再 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高代码执行效率。

#### 常用的线程池有哪些

newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。

newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。

newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。

newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

#### 线程池的好处

第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

#### 线程池原理

1.先判断线程池中的核心线程们是否空闲，如果空闲，就把这个新的任务指派给某一个空闲线程去执行。如果没有空闲，并且当前线程池中的核心线程数还小于 corePoolSize，那就再创建一个核心线程。

2.如果线程池的线程数已经达到核心线程数，并且这些线程都繁忙，就把这个新来的任务放到等待队列中去。如果等待队列又满了，那么查看一下当前线程数是否到达maximumPoolSize，如果还未到达，就继续创建线程。

3.如果已经到达了，就交给RejectedExecutionHandler(拒绝策略)来决定怎么处理这个任务。

> **拒绝策略**

线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。

**JDK 内置的拒绝策略如下： **

              1. AbortPolicy ： 直接抛出异常，默认。
                 2. CallerRunsPolicy ：不使用线程池执行，而使用启动线程池的线程来运行任务。
                 3. DiscardOldestPolicy ： 丢弃队列里最旧的一个线程，提交当前线程。
                 4. DiscardPolicy ： 不处理，直接丢弃掉。

#### 线程池的核心参数有哪些

**1.corePoolSize（核心线程数）**

​             （1）核心线程会一直存在，即使没有任务执行；

​             （2）当线程数小于核心线程数的时候，即使有空闲线程，也会一直创建线程直到达到核心线程数；

​             （3）设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。

**2.queueCapacity（任务队列容量）**

也叫阻塞队列，当核心线程都在运行，此时再有任务进来，会进入任务队列，排队等待线程执行。

**3.maxPoolSize（最大线程数）**

​             （1）线程池里允许存在的最大线程数量；

​             （2）当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务；

​             （3）线程池里允许存在的最大线程数量。当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务。

**4.keepAliveTime（线程空闲时间）**

​             （1）当线程空闲时间达到keepAliveTime时，线程会退出（关闭），直到线程数等于核心线程数；

​             （2）如果设置了allowCoreThreadTimeout=true，则线程会退出直到线程数等于零。

**5.allowCoreThreadTimeout（允许核心线程超时）**

**6.rejectedExecutionHandler（任务拒绝处理器）**

​             （1）当线程数量达到最大线程数，且任务队列已满时，会拒绝任务；

​             （2）调用线程池shutdown()方法后，会等待执行完线程池的任务之后，再shutdown()。如果在调用了shutdown()方法和线程池真正shutdown()之间提交任务，会拒绝新任务。

#### 线程池中线程的执行顺序

​     1. 当线程数小于核心线程数时，会一直创建线程直到线程数等于核心线程数；

​     2. 当线程数等于核心线程数时，新加入的任务会被放到任务队列等待执行；

​     3. 当任务队列已满，又有新的任务时，会创建线程直到线程数量等于最大线程数；

​     4. 当线程数等于最大线程数，且任务队列已满时，新加入任务会被拒绝。